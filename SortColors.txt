//approach - 1
//time complexity - O(nlogn)
//space complexity - O(nlogn), if we consider stack sorting space
// class Solution {
// public:
//     void sortColors(vector<int>& nums) {
//         sort(nums.begin(), nums.end());
//     }
// };

//approach - 2
//time complexity - O(n)
//space complexity -
// class Solution {
// public:
//     void sortColors(vector<int>& nums) {
//         int n = nums.size();
        
//         unordered_map<int, int> mp; //step1 - key - num, value - frequency
//         for(int &num: nums) { //store frequency of each number
//             mp[num]++;
//         }

//         //step2 - store in vector to sort
//         int idx = 0;
//         for(int i = 0; i < 3; i++) {
//             while(mp[i]--) {
//                 nums[idx] = i;
//                 idx++;
//             }
//         }
//     }
// };


//approach - 3
//time complexity - O(n)
//space complexity - O(1)
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();

        int i = 0; //for 0, going to move forward
        int j = 0; //for 1, going to move forward
        int k = n - 1; //for 2, going to move backward
        while(j <= k) {
            if(nums[j] == 2) { //if nums[j] == 2, swap with nums[k]
                swap(nums[j], nums[k]);
                k--;
            }
            else if(nums[j] == 0) { //if nums[j] == 0, swap with nums[i]
                swap(nums[j], nums[i]);
                i++;
                j++;
            }
            else { //if nums[j] == 1, just increment j, as we found nums[j] = 1
                j++;
            }
        }
    }
};









